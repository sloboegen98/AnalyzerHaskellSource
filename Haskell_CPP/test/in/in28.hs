{-
  В этом упражнении рассматриваются различные способы объявления
  функций:
    * однострочное определение,
    * сопоставление с образцом (pattern matching),
    * условное определение (охранные выражения, guarded expressions)
  и их комбинации.

  В каждом из заданий необходимо объявить функцию и вызвать её в интерпретаторе
  ghci с несколькими наборами параметров. После внесения изменений в файл его
  следует перезагружать командой :r. При работе в интерпретаторе удобно пользоваться
  клавишами "вверх" и "вниз" для перемещения по истории команд и клавишей TAB для
  автодополнения имён функций.
-}

-- 1) Удвоение значения заданного числа
-- (типовая аннотация здесь означает, что функция принимает один параметр
-- типа a и возвращает значение типа a, причём тип a принадлежит классу типов Num)
-- В решении необходимо заменить undefined на выражение, соответствующее удвоенному
-- значению аргумента x.

double :: Num a => a -> a
double x = 2*x

-- 2) Функция, возвращающая True тогда и только тогда, когда оба её аргумента равны True.
-- После типовой аннотации в объявлении функции следуют два варианта ("clause") её
-- определения, первый вариант соответствует ситуации, когда оба параметра равны True,
-- второй вариант используется во всех остальных случаях.
-- Слева от знака '=' и после имени функции стоят образцы параметров, они могут быть
-- именами переменных, константами или выражениями специального вида
-- (например, _ соответствует любому значению параметра).
-- Варианты определения рассматриваются сверху вниз, выбирается всегда первый
-- подходящий вариант определения.

bothTrue :: Bool -> Bool -> Bool
bothTrue True True = True
bothTrue _  _ = False

-- 3) Функция, возвращающая True, если только один из её аргументов равен True,
-- и False в противном случае (пользоваться стандартными логическими операциями не следует,
-- определение может содержать несколько вариантов).

oneTrue :: Bool -> Bool -> Bool
oneTrue True _ = True
oneTrue _ True = True
oneTrue False False = False

-- 4) Определение знака числа (-1, 0, 1)
-- В следующей типовой аннотации тип a должен принадлежать одновременно
-- классам Num и Ord, то есть его значения можно использовать в
-- арифметических операциях (Num) и сравнивать между собой (Ord).
-- После знака '|' указывается "охранное выражение", результатом
-- функции оказывается выражение, следующее за первым истинным охранным
-- выражением (otherwise является синонимом значения True, это всегда
-- истинное охранное выражение).

sign :: (Num a, Ord a) => a -> Int
sign a
   | a < 0 = -1 -- если a < 0
   | a == 0 = 0 -- иначе, если a равно 0
   | otherwise = 1 -- во всех остальных случаях

-- Сопоставление с образцом можно совмещать с охранными выражениями, например:

sign' :: (Num a, Ord a) => a -> Int
sign' 0 = 0
sign' a -- параметр гарантированно не равен 0
   | a < 0 = -1
   | otherwise = 1

-- 5) Утроение заданного числа
-- (типовую аннотацию и образцы параметров следует написать самостоятельно)
triple :: Num a => a -> a
triple x = x*3


-- 6) Определение наибольшего из трёх заданных целых чисел (можно воспользоваться
-- стандартной двухаргументной функцией max).

max3 :: Ord a => a -> a -> a -> a
max3 x y z = max (max x y) (max y z)

{-
  Проверка:
> max3 87 34 209
209
> max3 22 28 30
30
> max3 12 25 (-7)
25
-}

-- 7) Дана температура в градусах Фаренгейта. Вычислить соответствующую температуру
-- в градусах Цельсия.
f2c :: Double -> Double
f2c x = (x - 32) / 1.8

{-
   8) Найти наибольший общий делитель двух целых чисел, пользуясь
      алгоритмом Евклида (псевдокод):
      НОД(a, 0) = a.
      НОД(a, b) = НОД(b, a mod b), если b ≠ 0; 
-}


gcd' :: Integral a => a -> a -> a
gcd' x 0 = x
gcd' x y = gcd' y (mod x y)


{-
   9) Найти значение функции f(x), определённой правилом:
             −x,   если x ≤ 0,
    f(x) =   x^2,  если 0 < x < 2,
             4,    если x ≥ 2.

-}

eval_f :: (Num a, Ord a) => a -> a
eval_f x
	|x < 0 || x == 0 = -x
	|0 < x && x < 2 = x^2
	|x > 2 || x == 2 = 4

-- 10) Функция, возвращающая название дня недели по его номеру (от 1 до 7),
--    если номер неправильный, генерируется исключение (функция error).
--    В реализации следует пользоваться сопоставлением с образцами.
dayOfWeek :: Int -> String
dayOfWeek x
	|x < 1 || x > 7 = error "Incorrect data"
	|x == 1 = "Monday"
	|x == 2 = "Tuesday"
	|x == 3 = "Wednesday"
	|x == 4 = "Thursday"
	|x == 5 = "Friday"
	|x == 6 = "Saturday"
	|x == 7 = "Sunday"

-- 11) Написать функцию, возвращающую текстовую характеристику ("hot", "warm", "cool", "cold")
-- по заданному значению температуры в градусах Цельсия.
describeTemperature :: Double -> String
describeTemperature x
	|x > 35.1 = "hot"
	|x > 25.1 && x < 35.1 = "warm"
	|x > 15.1 && x < 25.1 = "cool"
	|x < 15.1 = "cold"

-- 12) Логическая операция xor (пользоваться стандартными логическими операциями не следует)

xor :: Bool -> Bool -> Bool
xor x y 
	| x == True && y == False = True
    | x == False && y == True = True
    | otherwise = False


-- 13) Площадь круга по заданному радиусу

areaCircle :: Double -> Double
areaCircle x = 3.14 * x * x

{-
  14) Дан номер года (положительное целое число). Определить количество дней в этом году,
  учитывая, что обычный год насчитывает 365 дней, а високосный — 366 дней. Високосным
  считается год, делящийся на 4, за исключением тех годов, которые делятся на 100 и
  не делятся на 400 (например, годы 300, 1300 и 1900 не являются високосными,
  а 1200 и 2000 — являются).
-}

-- является ли год високосным
isLeapYear :: Int -> Bool
isLeapYear x
	|(mod x 4 == 0) && (mod x 100 == 0) && (mod x 400 /=0) = True
	|otherwise = False

-- количество дней в году
nDays :: Int -> Int
nDays x = if isLeapYear x == True then 366 else 365

-- Функция isLeapYear является вспомогательной, поэтому её можно определить внутри
-- nDays:

nDays' :: Int -> Int
nDays' year
	|isLeap year /= True = 365
	|otherwise = 366
	where
		isLeap x = (mod x 4 == 0) && (mod x 100 == 0) && (mod x 400 /=0)
-- 15) Простой тест, проверяющий, все ли требуемые функции определены:

test = if bothTrue False True || oneTrue False False || True `xor` True || f2c 80 > 0  then
         (gcd' 128 76 + sign (-6) + sign' 5 + max3 12 27 32 + nDays 2015 + nDays' 2015,
          triple (double (eval_f 1.5)),
          dayOfWeek 3 ++ " " ++ describeTemperature (f2c 100))
         else (0, 0, "")

-- Выясните значение константы test в ghci, оно должно быть определено.
-- Этот тест не проверяет корректность определений функций.
--test = (766,13.5,"Wednesday hot")